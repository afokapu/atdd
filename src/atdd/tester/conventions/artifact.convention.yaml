# Artifact Convention
# Defines naming, versioning, organization, and API mapping rules for artifact-centric contracts
# Aligned with canonical artifact-naming.convention.yaml v2.1

description: "Artifact-centric contract system using theme-based hierarchical taxonomy with variant facets"

naming:
  logical_pattern: "{theme}(:{category})*:{aspect}(.{variant})?"
  physical_pattern: "contracts/{theme}/{segments}/{aspect}[/{variant}].schema.json"
  rationale: "Theme-based organization enables clear architectural boundaries. Colon separator denotes hierarchical descent (unlimited depth), dot separator denotes lateral variant (typically 0-1). Each segment becomes a directory level."

  examples:
    - logical: "commons:ux:foundations"
      physical: "contracts/commons/ux/foundations.schema.json"

    - logical: "commons:ux:foundations:color"
      physical: "contracts/commons/ux/foundations/color.schema.json"

    - logical: "mechanic:decision.choice"
      physical: "contracts/mechanic/decision/choice.schema.json"

    - logical: "match:result"
      physical: "contracts/match/result.schema.json"

    - logical: "sensory:gesture.raw"
      physical: "contracts/sensory/gesture/raw.schema.json"

versioning:
  location: "Separate version field"
  filename_pattern: "{segments}.schema.json"
  id_pattern: "{artifact_name}"
  version_field: "version"
  rationale: "Version tracked in separate 'version' field, NOT embedded in $id. Allows artifact identity to remain stable across versions. Supports monolithic deployment with coordinated releases."

  examples:
    - artifact: "commons/ux/foundations/color.schema.json"
      id_field: "commons:ux:foundations:color"
      version_field: "1.0.0"

    - artifact: "mechanic/decision/choice.schema.json"
      id_field: "mechanic:decision.choice"
      version_field: "1.0.0"

    - artifact: "match/result.schema.json"
      id_field: "match:result"
      version_field: "1.2.3"

    - artifact: "sensory/gesture/raw.schema.json"
      id_field: "sensory:gesture.raw"
      version_field: "1.0.0"

organization:
  strategy: "by_theme"
  directory_structure: "contracts/{theme}/"
  rationale: "Theme-based directories enable clear architectural boundaries. Each theme represents a bounded context. Unlimited hierarchical depth supported via colons."

  structure:
    root: "contracts/"
    themes:
      - "commons/"
      - "match/"
      - "mechanic/"
      - "sensory/"
      - "player/"
      - "scenario/"
      - "partnership/"
      - "league/"
      - "audience/"
      - "monetization/"

api_mapping:
  description: "Artifact names map to REST API endpoints for external consumption. Hierarchy levels add path segments, variants treated as resources."
  pattern: "/{theme}s/{id}/{segments}[/{variant}]"

  methods:
    new: POST
    created: POST
    registered: POST
    started: POST
    result: GET
    active: GET
    config: GET
    events: GET
    current: GET
    foundations: GET
    updated: PUT
    closed: PUT
    completed: PUT
    terminated: DELETE
    deleted: DELETE

  examples:
    - artifact: "commons:ux:foundations"
      endpoint: "GET /commons/{id}/ux/foundations"
      description: "Retrieve UX foundations"

    - artifact: "commons:ux:foundations:color"
      endpoint: "GET /commons/{id}/ux/foundations/color"
      description: "Retrieve UX color foundations"

    - artifact: "match:result"
      endpoint: "GET /matches/{id}/result"
      description: "Retrieve match result"

    - artifact: "session:new"
      endpoint: "POST /sessions"
      description: "Create new session"

    - artifact: "player:identity"
      endpoint: "GET /players/{id}"
      description: "Retrieve player identity"

    - artifact: "match:config"
      endpoint: "GET /matches/{id}/config"
      description: "Retrieve match configuration"

    - artifact: "player:updated"
      endpoint: "PUT /players/{id}"
      description: "Update player"

    - artifact: "match:terminated"
      endpoint: "DELETE /matches/{id}"
      description: "Terminate match"

ownership:
  producer: "Generates artifact contract (wagon that declares artifact in produce[])"
  consumer: "References existing contract (wagon that declares artifact in consume[])"
  single_source: "One artifact = one JSON file. Multiple wagons reference same file. Zero duplication."

  rules:
    - "Producer wagon owns the artifact schema generation"
    - "Consumer wagon validates artifact existence and references it"
    - "Artifact path declared in wagon manifest contract: field"
    - "Only producer generates; consumers must never modify"

metadata:
  description: "Artifact schemas include x-artifact-metadata for tooling and API generation"

  fields:
    theme: "Architectural theme (commons, match, mechanic, etc.)"
    aspect: "Final leaf resource noun"
    variant: "Optional lateral variation"
    api:
      method: "HTTP method (GET, POST, PUT, DELETE)"
      path: "REST endpoint path"

  example:
    theme: "match"
    aspect: "result"
    api:
      method: "GET"
      path: "/matches/{id}/result"

validation:
  required_fields: ["$schema", "$id", "version", "title", "type", "properties"]
  schema_compliance: "JSON Schema Draft-07"
  id_pattern: "^[a-z]+(?::[a-z][a-z0-9-]*)+(?:\\.[a-z][a-z0-9-]*)?$"
  version_pattern: "^\\d+\\.\\d+\\.\\d+$"

artifact_urns:
  urn_pattern:
    format: "contract:{artifact_name}"
    conversion_rule: "URN exactly matches artifact name - preserves colons for hierarchy and dots for variants. Pattern: contract:{theme}(:{category})*:{aspect}(.{variant})?"

  examples:
    artifact_to_urn:
      - artifact_name: "commons:ux:foundations"
        urn: "contract:commons:ux:foundations"

      - artifact_name: "commons:ux:foundations:color"
        urn: "contract:commons:ux:foundations:color"

      - artifact_name: "mechanic:decision.choice"
        urn: "contract:mechanic:decision.choice"

      - artifact_name: "sensory:gesture.raw"
        urn: "contract:sensory:gesture.raw"

  bidirectional_linkage:
    validation: "URN must resolve to a contract in the registry. All colons and dots preserved."

  migration_strategy:
    refactor_note: "Legacy URNs contract:{domain}:{resource}[.{category}] migrate to contract:{theme}(:{category})*:{aspect}(.{variant})?. Version suffix removed from $id."

wagon_artifacts:
  produce_example:
    wagon: "maintain-ux"
    produce:
      - name: "commons:ux:foundations"
        urn: "contract:commons:ux:foundations"
        to: "external"

      - name: "commons:ux:foundations:color"
        urn: "contract:commons:ux:foundations:color"
        to: "external"

  consume_example:
    wagon: "stage-characters"
    consume:
      - name: "commons:ux:foundations"
        urn: "contract:commons:ux:foundations"
        from: "wagon:maintain-ux"

contract_artifacts:
  id_field: "id: {artifact_name}"
  urn_mapping: "URN contract:{artifact_name} maps directly to $id {artifact_name}"

  example:
    - id: "commons:ux:foundations"
      version: "1.0.0"
      path: "commons/ux/foundations.schema.json"
      producer: "wagon:maintain-ux"
      urn_match: "contract:commons:ux:foundations"

    - id: "commons:ux:foundations:color"
      version: "1.0.0"
      path: "commons/ux/foundations/color.schema.json"
      producer: "wagon:maintain-ux"
      urn_match: "contract:commons:ux:foundations:color"

    - id: "mechanic:decision.choice"
      version: "1.0.0"
      path: "mechanic/decision/choice.schema.json"
      producer: "wagon:resolve-dilemmas"
      urn_match: "contract:mechanic:decision.choice"

demo_mode:
  description: "Artifacts write to demo/contracts/artifacts/ when mode_demo: true"
  path_prefix: "demo/contracts/artifacts/"

examples:
  complete_workflow:
    - step: "Wagon declares artifact in produce[]"
      example: |
        produce:
          - name: mechanic:decision.choice
            to: external
            contract: contracts/mechanic/decision/choice.schema.json

    - step: "Tester agent classifies artifact ownership"
      result: "producer: true, path: mechanic/decision/choice.schema.json"

    - step: "Schema generation creates artifact"
      output: "contracts/mechanic/decision/choice.schema.json"
      content: |
        {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "$id": "mechanic:decision.choice",
          "version": "1.0.0",
          "title": "Decision Choice",
          "type": "object",
          "properties": {...},
          "x-artifact-metadata": {
            "theme": "mechanic",
            "aspect": "decision",
            "variant": "choice",
            "api": {
              "method": "POST",
              "path": "/decisions"
            }
          }
        }

    - step: "Consumer wagon references artifact"
      example: |
        consume:
          - name: mechanic:decision.choice
            from: wagon:resolve-dilemmas
            contract: contracts/mechanic/decision/choice.schema.json

    - step: "Pack generation references (not embeds) artifact"
      pack_manifest: |
        produce:
          - artifact: mechanic:decision.choice
            contract: ../artifacts/mechanic/decision/choice.schema.json
            owner: true
